#!/usr/bin/perl
# ==============================================================================
#
#		NoDeny - подпрограммы разрешения/блокировки доступа
#
# ==============================================================================
#
# Данный скрипт управляет созданием правил в фаерволе разрешающих/запрещающих/shape-щих трафик клиентов.
# Скрипт можно редактировать для выполнения ваших конкретных задач. Фаервол ipfw - в данном случае.
#
# Определения:
# 1. Входящий/исходящий трафик рассматривается по отношению к клиенту, например, speed_in - 
# входящая скорость для клиента. Для сервера же этот трафик, естественно, будет исходящим.
#
# 2. Альтернативные направления - список сетей, для трафика в которые можно указать скорость
# независимо от основной скорости пакета. Например, тариф `unlim 512кбит + 2048кбит видеосервер` -
# подразумевает, что альтернативные направления будут включать в себя список ip видеосерверов.
# Список ip алт. направлений задается в таблице 126 ipfw, сети заносятся туда автоматически (!)
# после того как в настройках направлений (в админке NoDeny) для определенного названия направления
# вы укажете, что все сети этого направления необходимо занести в таблицу 126 ipfw.
# Если в тарифе не указана скорость к алт. направлением - фича не задействуется.
#
# nofire.pl вызывается из noserver.pl и выполняет его команды (подпрограммы):
#  Flush		- Приводит ipfw в исходное состояние - удаляет все правила в диапазоне использования NoDeny,
#			формирует правила с шейпами. В правилах, используются таблицы ipfw, поэтому дальнейшая работа
#			скрипта заключается в добавлении/удалении ip клиентов из таблиц. Если же для заданного клиента
#			необходимо применить иные механизмы шейпов, то для него формируются персональные правила.
#
#  Add_To_All_Ip	- вызывается для каждого существуещего ip в NoDeny вне зависимости от группы, состояния
#			доступа и авторизации. Таким образом, подпрограмма получит последовательно все
#			существующие ip и занесет их в таблицу 2 (в данном случае). Это необходимо для того, чтобы
#			на уровне фаервола понять куда идет трафик - в интернет или к другому клиенту. Дело в том,
#			что если трафик идет к другому клиенту, то будет дополнительная проверка - авторизован
#			ли и разрешен ли доступ у целевого клиента (есть ли он таблице 1 ipfw), причем неважно
#			на данном либо ином маршрутизаторе.
#
#  Delete_From_All_Ip	- вызывается когда noserver.pl обнаруживает, что определенный ip удален из биллинга.
#
#  Add_To_Table		- вызывается когда необходимо добавить определенную сеть в определенную таблицу.
#			В настройках направлений указываются сети каких направлений должны попасть в какие таблицы
#
#  Delete_From_Table
#
#  Allow		- вызывается, когда заданному ip необходимо включить доступ
#
#  Deny			- -//- заблокировать доступ
#
#  Run_Ipfw_Rules	- вызывается когда noserver.pl желает выполнить все подготовленные в $Rules команды ipfw,
#			при этом они скидываются в файл, после чего тот скармливается ipfw-утилите.
#
# ==============================================================================
#
# Описания таблиц ipfw, используемых скриптом: 
#  0 -	ip клиентов, которых обслуживает данный сателлит и для которых выполняются условия, описанные в
#	конфиге сателлита, по умолчанию:
#	  - клиент авторизован и доступ не заблокирован
#	  - клиент в состоянии `всегда онлайн` и доступ не заблокирован
#	Если в данной таблице нет нужного вам ip, а должен быть - возможно, клиент в группе, которую не
#	обслуживает данный сателлит.
#  1 -  ip авторизованных, а также `всегда онлайн`, незаблокированных клиентов всех групп! Не только
#	тех, которые обслуживает данный сателлит. Эта таблица заполняется только если запущено ядро nodeny.
#  2 -	полный список всех ip NoDeny вне зависимости от авторизации и др. параметров.
#
# 10 -	ip и pipe-ы для шейпов трафика, идущего к клиенту. Например
#		bash# ipfw table 10 list | grep 10.0.0.5
#		      10.0.0.5/32 1234
#		bash# ipfw pipe 1234 show
#		      01234: 512.000 Kbit/s
#	Здесь входящая скорость на клиента ограничена 512 кбит. 
#	В 10 таблицу не обязательно попадают все `включенные ip` - в зависимости от условий (модификаторы скоростей,
#	персональные параметры) для ip могут быть сформированы персональные правила в ipfw
#
# 11 -	То же для трафика от клиента
#
# 15 -	ip, которым заблокирован доступ к запрещенным портам
#
# 20,21 - шейпы для трафика `клиент -> клиент`, т.е трафик между ip, которые ОБА присутствуют в NoDeny
#
# ==============================================================================
#
# Для любого клиента, если у него в пакете не указна скорость, можно указать персональную, которая
# указывается в дополнительных полях учетной записи клиента.
# В `Операции` -> `Настройки` -> `Дополнительные поля` необходимо создать 3 поля (если их там нет)
#  1) входящая скорость (алиас: _speed_in)
#  2) исходящая скорость (алиас: _speed_out)
#  3) разрешение открытие 25го порта (алиас: _open_ports)
# Важны не названия полей, а алиасы, которые в точности должны совпадать с указанными!
# В настройках сателлита необходимо указать номер шаблон, в котором эти поля находятся.
# Скорости задаются в килобайтах/сек.

$IPFW='/sbin/ipfw -q ';
$FW=$IPFW;

# Для отладки установите $Del_Files=0 - сформированные файлы с командами ipfw не будут удаляться после выполнения
$Del_Files=1;
# Если раскомментировать следущую строчку  - вместо выполнения, ipfw команды будут выводиться в STDOUT
#$FW='/bin/cat'; 

# Следующий кусок кода будет выполнен при старте noserver.pl, здесь мы иннициализируем переменные.
# Если у клиента в пакете или в личных данных не указаны скорости, то будут выставлены стандартные.
# Стандартные указываются в конфиге сателлита, если там не указаны, то принимает такие:

$default_in=(int $c{DefaultSpeedIn}) || 8192;		# скорость к клиенту, кбит
$default_out=(int $c{DefaultSpeedOut}) || 1024;		# скорость от клиентаб кбит

# Список запрещенных tcp портов. По умолчанию всем будет запрещено создавать соединения на эти порты, однако
# в данных клиента можно разрешить персонально. Пример запрещения smtp: $denied_ports='25';

$denied_ports=$c{Denied_ports} || 0;

# ============================
# Вспомогательные подпрограммы

# По заданному id клиента возвращает два номера правила ipfw: `трафик от клиента` и `на клиента`
# Делаем буфер в 500 правил т.к формируем общие правила в начале окон ipfw
sub Get_Ipfw_Num
{
 return($_[0]+$Start_num_ipfw+500,$_[0]+$Start_num2_ipfw+500); 
}

# По id клиента генерируем номер pipe
# Будут начинаться с 1000 (до этого зарезервированы), умножение на 4 - это 4 пайпа под каждый ip
sub Get_Pipe_Num
{
 return($_[0]*4+1000); 
}
 
sub Add_Rule
{
 $Rules.=$_[0]."\n";
 $nRules++;
}

sub SetIpfwRule
{
 &Add_Rule('add '.$NumIpfw++.' '.$_[0]);
}
 
# 0 - таблица
# 1 - ip
# 2 - tablearg
sub Add_Tbl_Rule
{
 return if $Tbl{$_[1]}{$_[0]};
 $Tbl{$_[1]}{$_[0]}=1;
 $Rules.="table $_[0] add $_[1] $_[2]\n";
}

sub Flush
{
 # 1. Удаляет из фаервола все правила в диапазонах ($Start_num_ipfw .. $End_num_ipfw) и ($Start_num2_ipfw .. $End_num2_ipfw),
 #    т.е. освобождет 2 окна, в которых будут формироваться динамические правила
 # 2. Формирует общие правила в созданных окнах

 %Pipe_count=();	# счетчик использования пайпов, как только на пайп перестают ссылаться - он удаляется
 %Pipe_used=();		# какой клиент какой pipe использует...

 $Rules='';

 my @lines=split /\n/,`$IPFW list`;
 my $num=0;
 foreach (@lines)
 {
    next if !/^\s*(\d+)/ || $num==$1; # на правиле может быть несколько записей
    $num=$1;
    &Add_Rule("delete $1") if ($1>=$Start_num_ipfw && $1<=$End_num_ipfw) || ($1>=$Start_num2_ipfw && $1<=$End_num2_ipfw);
 }

 &Add_Rule("table 0 flush");	# ip авторизованных клиентов, неважно в каком режиме
 &Add_Rule("table 1 flush");	# ВСЕ включенные ip NoDeny, не только обслуживаемых групп клиентов
 &Add_Rule("table 2 flush");	# ВСЕ ip NoDeny, не только обслуживаемых групп клиентов
 &Add_Rule("table 10 flush");	# ip и пайпы трафика к клиенту
 &Add_Rule("table 11 flush");	# ip и пайпы трафика от клиента
 &Add_Rule("table 15 flush");	# для ip, которым заблокирован доступ к запрещенным портам (по умолчанию все попадают в этот список)
 &Add_Rule("table 20 flush");	# шейпы для клиент -> клиент
 &Add_Rule("table 21 flush");	# шейпы для клиент -> клиент

 &Add_Rule("-f pipe flush");
 &Add_Rule("pipe 1 config bw 0bit/s"); # скорость 0 указывает на отсутствие шейпа, т.е unlimited

 $Start_num_ipfw_4tbl=$Start_num_ipfw+100;				# с этого правила будут формироваться таблицы
 $Start_num2_ipfw_4tbl=$Start_num2_ipfw+100;

 $NumIpfw=$Start_num_ipfw;

 my $n1=$NumIpfw+10;
 my $n2=$NumIpfw+400;
 my $n3=$n1+20;
 &SetIpfwRule(qq{deny ip from not table(0) to any});			# запретим любой входящий трафик от незарегистрированных либо невключенных ip
 &SetIpfwRule(qq{skipto $n1 ip from table(127) to table(126)});		# переход на: клиент -> альт. направление
 &SetIpfwRule(qq{skipto $n3 ip from any to not table(2)});		# переход на: клиент -> не другой клиент ( -> мир)
 &SetIpfwRule(qq{deny ip from any to not table(1)});			# запретить трафик к невключенным зарегистрированным ip
 &SetIpfwRule(qq{pipe tablearg ip from table(21) to any});		# клиент -> клиент
 &SetIpfwRule(qq{deny ip from any to any});

 # сюда skipto 
 $NumIpfw=$n1;
 &SetIpfwRule(qq{pipe tablearg ip from table(127) to any});		# клиент -> альт. направление
 $NumIpfw=$n3;
 &SetIpfwRule(qq{deny tcp from table(15) to any $denied_ports});	# клиент -> запрещенные порты
 $NumIpfw=$n2;
 &SetIpfwRule(qq{pipe tablearg ip from table(11) to any});		# клиент -> мир
 $NumIpfw=$End_num_ipfw;
 &SetIpfwRule(qq{deny ip from any to any});

 $NumIpfw=$Start_num2_ipfw;

 $n1=$NumIpfw+10;
 $n2=$NumIpfw+400;

 &SetIpfwRule(qq{pipe tablearg ip from table(126) to table(127)});	# альтернативное направление -> клиент
 &SetIpfwRule(qq{skipto $n1 ip from not table(2) to any});		# не от клиента -> 
 &SetIpfwRule(qq{pipe tablearg ip from any to table(20)});		# клиент -> клиент
 &SetIpfwRule(qq{deny ip from any to any});
 # $n1 ... $n2 буфер для таблиц направлений
 $NumIpfw=$n2;
 &SetIpfwRule(qq{pipe tablearg ip from any to table(10)});		# мир -> клиент
}


sub Add_To_All_Ip
{
 &Add_Rule("table 2 add $_[0]");
}

sub Delete_From_All_Ip
{
 &Add_Rule("table 2 delete $_[0]");
}

sub Add_To_Allow_Ip
{
 &Add_Rule("table 1 add $_[0]");
}

sub Delete_From_Allow_Ip
{
 &Add_Rule("table 1 delete $_[0]");
}

sub Add_To_Table
{
 my ($net,$tbl)=@_;
 if( !$ExistRuleForTbl{$tbl} )
 {
    $ExistRuleForTbl{$tbl}=1;
    $_=$tbl+1;
    &Add_Rule("table $_ flush");
    &Add_Rule("table $tbl flush");
    my $tbl_from="table($_)";
    my $tbl_to="table($tbl)";
    $_=$Start_num_ipfw_4tbl+$tbl;
    &Add_Rule("add $_ allow ip from $tbl_from to $tbl_to");
    $_=$Start_num2_ipfw_4tbl+$tbl;
    &Add_Rule("add $_ allow ip from $tbl_to to $tbl_from");
 }
 &Add_Rule("table $tbl add $net");
}

sub Delete_From_Table
{
 &Add_Rule("table $_[1] delete $_[0]");
}

sub Flush_Table
{
 &Add_Rule("table $_[0] flush");
}

# ====================
#  Блокировка доступа
# ====================
sub Deny
{
 my $p=$_[0];
 my $num=$p->{num};
 my $ip=$p->{ip};
 my ($num1,$num2,$tbl,$pipe);
 # удалим ip из всех таблиц, в которые он был записан
 foreach $tbl (keys %{$Tbl{$ip}})
 {
    &Add_Rule("table $tbl delete $ip");
    delete $Tbl{$ip}{$tbl};
 } 

 if( $Need_Del_Rule{$ip} )
 {
    $Need_Del_Rule{$ip}=0;
    ($num1,$num2)=&Get_Ipfw_Num($num);
    # добавим защиту от случая, когда кто-то удалит вручную правило, тогда выполнение потока команд прервется,
    # такая особенность работы ipfw. Добавим безобидное правило, чтобы его тут же удалить вместе с основным
    &Add_Rule("add $num1 count ip from any to any");
    &Add_Rule("delete $num1");
    &Add_Rule("add $num2 count ip from any to any");
    &Add_Rule("delete $num2");
 }
 $pipe=$Pipe_used{$num};		# данный ip использовал такой pipe
 if( --$Pipe_count{$pipe}<=0 )
 {  # больше данный pipe никто не использует, удалим
    $Pipe_count{$pipe}=0 if $Pipe_count{$pipe}; # перестраховка, в реальности не должно никогда сработать
    $num=3;
    while( $num-- )
    {  # на самом деле на каждого клиента приходится 3 pipe, удалим все
       &Add_Rule("pipe $pipe config");
       &Add_Rule("pipe $pipe delete");
       $pipe++;
    }
 }
}


# ==================
# Разрешение доступа
sub Allow
{
 my $p=$_[0];
 my($auth,$dop_param,$i,$id,$ip,$mid,$n,$num,$num1,$num2,$opt,$options);
 my($paket,$pipe2,$pipe_in,$pipe_out,$speed2,$speed_in,$speed_out);

 $ip=$p->{ip};
 $id=$p->{id};			# id текущей записи (по таблице users)
 $num=$p->{num};		# виртуальный уникальный id текущей записи
 $mid=$p->{mid};		# id основной записи (по таблице users)
 $auth=$p->{auth};		# режим авторизации (on,off,ong)
 $paket=$p->{paket};
 $speed2=$p->{speed2};		# альтернативная скорость, указанная в пакете
 $options=$p->{options};	# модификаторы скорости
 $main_num=$p->{main_num};	# виртуальный уникальный id основной записи
 $speed_in=$p->{speed_in};	# скорость к клиенту, указанная в пакете
 $speed_out=$p->{speed_out};
 $dop_param=$p->{dop_param};	# дополнительные параметры учетки клиента
 $plan_flags=$p->{plan_flags};	# флаги пакета тарификации

 ($num1,$num2)=&Get_Ipfw_Num($num); # номера правил ipfw `от клиента` и `на клиента`
 $Need_Del_Rule{$ip}=0;		# признак, что для $ip персонального правила не создано,
 				# 0 останется если все будет оформлено через таблицы

 &Add_Tbl_Rule(0,$ip);

 my $s_in=$dop_param->{_speed_in};		# входящая скорость в учетке клиента, кб/сек
 my $s_out=$dop_param->{_speed_out};		# исходящая скорость в учетке клиента, кб/сек
 my $a_ports=$dop_param->{_open_ports};		# не блокировать запрещенные порты?

 #  Если скорости не указаны, то берутся значения по умолчанию (из конфига сателлита)

 if( $speed_in )
 {  # Cкорость указана в пакете. Это самая приоритетная скорость, даже если в учетной
    # записи в доп параметре указана другая. Получим уникальный номер pipe по основной записи:
    # $main_num - трафик всех алиасов должен попадать в один pipe!
    $pipe_in=&Get_Pipe_Num($main_num);
    &Add_Rule("pipe $pipe_in config bw ${speed_in}Kbit/s");
    if( $speed_out )
    {  # указана скорость от клиента, для нее отдельный pipe
       $pipe_out=$pipe_in+1;
       &Add_Rule("pipe $pipe_out config bw ${speed_out}Kbit/s");
    }
     else
    {  # входящий и исходящий трафик в одной трубе
       $speed_out=$speed_in;
       $pipe_out=$pipe_in;
    } 
 }
  else
 {  # Если какая-либо скорость не указана - берем стандартную. Нулевая скорость в пайпах = allow
    $pipe_in=&Get_Pipe_Num($num);
    $pipe_out=$pipe_in+1;
    $speed_in=$s_in>0? $s_in*8 : $default_in;
    $speed_out=$s_out>0? $s_out*8 : $default_out;
    &Add_Rule("pipe $pipe_in config bw ${speed_in}Kbit/s");
    &Add_Rule("pipe $pipe_out config bw ${speed_out}Kbit/s");
 }

 # Трафик между ip и другими клиентами
 if( $plan_flags=~/j/ )
 {  # пакет указывает шейпить локальный трафик для данного ip
    &Add_Tbl_Rule(20,$ip,$pipe_in);
    &Add_Tbl_Rule(21,$ip,$pipe_out);
 }
  else
 {  # pipe № 1 - пайп unlimited 
    &Add_Tbl_Rule(20,$ip,1);
    &Add_Tbl_Rule(21,$ip,1);
 }

 $Pipe_used{$num}=$pipe_in;		# запомним какой pipe использует данный ip
 $Pipe_count{$pipe_in}++;		# увеличим счетчик использования pipe - один пайп может использоваться
 					# несколькими клиентскими ip - алиасами

 ($auth eq 'off') && return;		# авторизация в режиме `разрешить только локальный трафик`

 if( $speed2 )
 {  # к альтернативным направлениям в пакете указана скорость
    $pipe2=$pipe_in+2;			# pipe для трафика в альтернативные направления
    &Add_Rule("pipe $pipe2 config bw ${speed2}Kbit/s");
    &Add_Tbl_Rule(127,$ip,$pipe2);
 }

 if( $a_ports )
 {  # для данного клиента разрешить доступ к портам, которые в списке запрещенных
    if( $TBL_15{$ip} )
    {
       &Add_Rule("table 15 delete $ip");
       $TBL_15{$ip}=0;
    }
 }else
 {  # для данного клиента запретить доступ к портам, которые в списке запрещенных
    if( !$TBL_15{$ip} )
    {
       &Add_Rule("table 15 add $ip");
       $TBL_15{$ip}=1;
    }
 }

 # Подпрограмма отключает шейп трафика для сетей указанного пресета и направления
 sub set_allow
 {
   my($id,$ip,$paket,$num1,$num2)=@_;
   $id=$Plan_preset[$paket].'-'.$id;	# id таблицы = пресет-номер_направления
   my $tbl=$Tables{$id};		# таблица содержащая сети заданного пресета и направления
   if( $tbl )
   {  # таблица существует и заполнена
      if( $ExistRuleForTbl{$tbl} )
      {  # кроме того есть правило, которое делает allow из таблицы $tbl+1 в $tbl и обратно
         # т.е. не нужно формировать дополнительные правила
         $tbl++;
         &Add_Tbl_Rule($tbl,$ip,1);
      }else
      {
         $Need_Del_Rule{$ip}=1;
         &Add_Rule(qq{add $num1 allow ip from $ip to table($tbl)});
         &Add_Rule(qq{add $num2 allow ip from table($tbl) to $ip});
      } 
   }
    elsif( $NET{$id} )
   {
      $Need_Del_Rule{$ip}=1;
      &Add_Rule("add $num1 allow ip from $ip to $NET{$id}");
      &Add_Rule("add $num2 allow ip from $NET{$id} to $ip");
   }
 }

 if( $options )
 {# есть модификаторы скорости
    foreach $opt (split /\n/,$options)
    {
       $opt=~/^(\d+):(\d+)$/ or next;	# поврежденная структура, игнорируем
       &set_allow($1,$ip,$paket,$num1,$num2);
    }
 }

 # пакет указывает не шейпить трафик клиента сети в определенные направления?
 $plan_flags=~/x/ && &set_allow('2',$ip,$paket,$num1,$num2);
 $plan_flags=~/y/ && &set_allow('3',$ip,$paket,$num1,$num2);
 $plan_flags=~/z/ && &set_allow('4',$ip,$paket,$num1,$num2);

 # -> клиент
 if( $Need_Del_Rule{$ip} )
 {# нельзя записывать в таблицу т.к после нее созданы правила, которые логически должны быть обработаны до правила с таблицей
    &Add_Rule("add $num2 pipe $pipe_in ip from any to $ip");
 }
  else
 {
    &Add_Tbl_Rule(10,$ip,$pipe_in);
 }
 # клиент ->
 if( $Need_Del_Rule{$ip} )
 {
    &Add_Rule("add $num1 pipe $pipe_out ip from $ip to any");
 }
  else
 {
    &Add_Tbl_Rule(11,$ip,$pipe_out);
 }
}

sub Run_Ipfw_Rules
{
 return unless $Rules;
 my $fname=$Program_dir.'/'.time();
 if( open(F,">>$fname") )
 {
    print F $Rules;
    close (F);
    $Rules='';
    system("$FW $fname");
    $Del_Files && unlink $fname;
 }
}

1;

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Nodeny - Install</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<link rel='stylesheet' href='../i/nody.css' type='text/css'>
</head>
<body>

<div class='mainbody'>
<table border=0 width=90% class="coment"><tr>
<td><a href="../index.html"><img src="../i/logo.gif" border=0 valign=middle></a></td>
<td align=center><b>Биллинговая система NoDeny. Структура таблиц БД</b></td>
</tr></table>
<br><br><br>

Детальное описание таблиц.<br>
<ul>
<li><a href="#admin">admin</a></li>
<li><a href="#arch">arch_users</a></li>
<li><a href="#cards">cards</a></li>
<li><a href="#dblogin">dblogin</a></li>
<li><a href="#dopdata">dopfields / dopvalues / dop_oldvalues / dopdata</a></li>
<li><a href="#files">files</a></li>
<li><a href="#login">login</a></li>
<li><a href="#pays">pays</a></li>
<li><a href="#users">users</a></li>
<li><a href="#s">s-таблицы</a></li>
<li><a href="#t">t-таблицы</a></li>
<li><a href="#x">x-таблицы</a></li>
<li><a href="#y">y-таблицы</a></li>
<li><a href="#z">z-таблицы</a></li>
</ul>
<br>
<a name="db"><div class="coment" align=center><b>Таблицы баз данных</b></div></a><br>
<br>
Для распределения нагрузки система NoDeny работает с несколькими базами данных, которые могут находиться
на разных серверах. В простейшем случае можно все указатели установить на одну базу данных, это корректная
операция. Автор именует базы данных как: основная, дополнительная и база авторизации.<br>
<br>
<b>Дополнительная база данных</b> не хранит ключевую информацию, поэтому не так требовательна к надежности
как основная.
Большинство таблиц в дополнительной БД создаются автоматически ядром NoDeny - для каждого дня своя таблица.
Это с одной стороны облегчает удаление устаревших данных, с другой стороны возможные объемы данных
могут быть гигантскими, в частности в сети автора ведется полная детализация трафика, что
составляет примерно 200 млн. записей в сутки. C такими объемами гораздо оптимальнее работать когда
каждая таблица ответственна за определенный день месяца.<br>
<br>
Трафик хранится в таблицах разных типов, последние определяются по первой букве имени таблицы. Необходимо отметить,
что в системе NoDeny трафик предназначен не только для тарификации клиента. Ведется статистика по т.н.
"нулевому пресету". Эта статистика предназначена для тех случаев, когда вы хотите оценивать трафик по критериям
вашего вышестоящего провайдера. Например, последний продает вам канал без разделений на типы (внешний, городской,
игровой и т.д), которые вы применяете в тарификации для своих клиентов. В таком случае, вы можете анализировать
статистику по нулевому пресету для определения реальной загрузки ваших каналов.<br>
<br>
Исходя из существования понятия "нулевой пресет", NoDeny для каждой таблицы определенного типа создает
аналог, в котором обсчет производится на основе нулевого пресета. Так аналогом таблицы <b>x</b> является
таблица <b>s</b>, а для <b>x</b> - <b>y</b>.<br>
<br>
<br>

Типы таблиц с трафиком:<br>
<br>



- <b><a name="x">x-таблицы</a></b> содержат информацию об объемах трафика, потребленных каждым
клиентом за каждый период снятия статистики.<br>
<div class="coment" align=center>
Структура:<br>
<br>
<pre>
 mid	- id клиента (см. таблицу users);
 time	- время среза статистики в формате timestamp;
 class	- номер направления, которым классифицированы данные объемы трафика
 in	- трафик к клиенту, байт;
 out	- трафик от клиента, байт.
</pre>

Если клиент за период снятия статистики сформировал трафик нескольких направлений, то создается
несколько записей с разными class, но с одним time.
</div><br>
<br>



- <b><a name="y">y-таблицы</a></b> аналогичны x-таблицам, однако направления определяются на основе
нулевого пресета, а не на основе пакета тарификации клиента.<br>
<br>
<br>


- <b><a name="z">z-таблицы</a></b> содержат максимально детализированную статистику по ip, портам и протоколам
для трафика каждого абонента для которого включена такая функция. Эти таблицы наиболее требовательны к ресурсам
памяти т.к. хранят очень большое количество информации. Последнее является причиной почему таблицы с трафиком
создаются персонально для каждого дня.<br>
<div class="coment" align=center>
Структура:<br>
<br>
<pre>
 mid		- id клиента (см. таблицу users);
 time		- время среза статистики в формате:
		  timestamp минус timestamp начала суток;
 bytes		- трафик, байт;
 direction	- направление, 0 - от клиента, 1 - к клиенту;
 ip		- ip удаленной стороны, упакованный в 4 байта;
 port		- порт удаленной стороны;
 proto		- номер протокола.
</pre>
Время среза статистики для уменьшения объема таблицы предоставлено в сокращенном виде. Как известно, timestamp
сообщает о количестве секунд, прошедших с начала 1970 года. В нашем случае за начало принимается
0 часов 0 минут тех суток, на которые предоставлена информация. Таким образом, если значение time = 10 в 
таблице z2008x3x8, то оно будет указывать на срез 10 секунд 8 марта 2008 года.
</div><br>
<br>



- <b><a name="s">s-таблицы</a></b> хранят общий за сутки трафик каждого клиента. Эти таблицы формируются
&#171;задним числом&#187; только при наступлении новых суток. Ядро NoDeny на основе x-таблицы соответствующего
дня формирует s-таблицу для этого дня.</b><br>
<div class="coment" align=center>
Структура:<br>
<br>
<pre>
 mid	- id клиента (см. таблицу users);
 class	- номер направления, которым классифицированы данные объемы трафика;
 in	- трафик к клиенту, байт;
 out	- трафик от клиента, байт.
</pre>
Видно, что таблица аналогична x-таблице, за исключением отсутствия поля time, поскольку хранит
информацию не за срез, а за целые сутки.
</div><br>
<br>

- <b><a name="t">t-таблицы</a></b> аналогичны s-таблицам, хранят суммарную статистику трафика y-таблиц.<br>
<br>
<br>

- <b><a name="v">v-таблицы</a></b> хранят информацию об иных статистических показателях: сколько
потоков трафика сформировал абонент, сколько было зарегистрировано в детальной статистике, было ли превышение
допустимого количества регистрируемых потоков, велась ли вообще детализация и др.<br>
<br>
<br>



- <b>traf_lost</b> - таблица &#171;неучтенного&#187; трафика, хранит данные о трафике, который не удалось классифицировать,
что свидетельствует о неправильной настройке системы, например, пробросе трафика вне контроля NoDeny либо
неправильной настройке NoDeny.<br>
<br>
<br>


- <b>user_select</b> - вспомогательная таблица, используется для временного хранения ключевых данных клиентов
когда необходимо выполнить сложный sql-запрос из разных баз данных, что пока невозможно СУБД mysql, поэтому
данные клиентов из основной базы копируются в эту таблицу.<br>
<br>
<br>
<br>
<br>



<b>Основная база данных</b> содержит такие таблицы:<br>
<br>
- <b><a name="admin">admin</a></b> - таблица со списком администраторов и их привилегиями:<br>
<br>
<div class="mess">
<pre>
 id	 	- id администратора;
 office  	- отдел (см. таблицу offices);
 admin	 	- логин;
 passwd  	- зашифрованный пароль;
 session 	- идентификатор текущей сессии;
 session_expire	- когда сессия будет удалена;
 name	 	- имя админа;
 post	 	- должность;
 privil	 	- привилегии;
 regions 	- приоритетные районы;
 tunes	 	- персональные настройки;
 pay_mess	- список предустановленных комментариев для платежей;
 ext	 	- расширение у аватара;
 email	 	- почтовый ящик;
 email_grp	- от каких групп клиентов получать письма по почте;
 mess	 	- сообщение от главного администратора;
 temp_block_grp	- временная блокировка доступа к определенным группам клиентов;
</pre>
Привилегии задаются в виде списка чисел, разделенных запятыми. Каждое число указывает на то,
что соответствующая ему привилегия включена. Список соответствий число=привилегия можете узнать
из файла admin.pl.
</div>
<br>

- <b>admin_session</b> - активные на данный момент веб-сессии администраторов.<br>
<br>

- <b>config</b> - таблица конфигурационных файлов. Система NoDeny оформляет конфигурацию в виде текстового файла,
но при этом дублирует ее в базу данных, причем не замещает текущую, а создает новую запись. Благодаря этому
всегда можно сделать откат. В поле time - время записи конфига. Ядро NoDeny при загрузке выбирает самый поздний
по времени.<br>
<br>

- <b>conf_sat</b>. При старте агенты на сателитах загружают свои конфигурационные файлы из этой таблицы.<br>
<br>
<div class="mess">
<pre>
 id	- id сателлита;
 time	- время последней модификации конфига;
 login	- логин сателлита;
 name	- имя;
 comment - комментарий;
 config	- непосредственно конфиг в виде текстового блока, в котором каждая строка описывает
	  определенный конфигурационный параметр. Шаблон параметров задается в файле satellite.cfg
 Passwd_Key - ключ шифрования паролей в базе данных. Должен сответствовать значению $Passwd_Key в
	  файле nodeny.cfg.pl, в противном случае авторизация клиентов не будет проходить.
</div>
<br>

- <b><a name="dblogin">dblogin</a></b> - таблица-<em>очередь</em>, авторизированных разными агентами, клиентов. Данные впоследствии
обрабатываются ядром NoDeny.<br>
<br>
<div class="mess">
<pre>
 id	- порядковый номер записи;
 mid	- id учетной записи клиента (см. таблицу users);
 act	- режим авторизации;
 time	- время авторизации (timestamp).
</pre>
Режим авторизации состоит из двух частей: кода агента, который принял авторизацию и кода авторизации.
Смотрите описание к таблице login.
</div>
<br>




- <b>files</b> - через эту таблицу происходит обмен файлами между модулями NoDeny. В частности, через эту таблицу
ядро NoDeny передает агентам доступа списки сетей, которые находятся не в БД, а загружаются, скажем, с другого сайта -
сети UA-IX, например.<br>
<br>



- <b>nets</b> - список описаний направлений, содержит информацию по сетям каждого пресета.<br>
<br>
<br>




- <b><a name="pays">pays</a></b> - таблица событий (переводится как &#171;платежи&#187;, что наследовано от
предыдущих версий NoDeny). Хранит все события связанные с каждым абонентом и сетью: регистрация изменения данных,
ошибочные действия, сообщения, платежи, события и т.д.<br>
<div class="mess">
Структура:<br>
<br>
<pre>
 id		- уникальный id записи;
 mid		- id клиента (см. таблицу users);
 cash		- денежная сумма, для всех нефинансовых записей = 0;
 time		- время формирования записи, timestamp;
 admin_id	- id администратора (см. табл. admin), который сформировал запись,
		  если запись сформировал клиент или система (например, ядро) = 0;
 admin_ip	- ip администратора/клиента с которого было произведено
		  формирование данного события. Для ядра = 0, что соответствует 0.0.0.0,
		  ip упаковывается в 4 байта;
 office		- номер отдела, в котором работает админ сформировавший запись.
		  Для ядра и клиентов = 0;
 bonus		- для финансовых платежей указывает безналичный ли платеж;
 reason		- многофункциональное поле. В зависимости от типа платежа (type) и
		  категории (category) может являться:
	- комментарием для администратора, если запись является сообщением;
	- информацией о каком-то событии, например, какие поля в учетной записи были изменены;
	- закодированным событием, например, данные о работе.
 coment		- многофункциональное поле. Обычно хранит сообщение для клиента.
 type		- тип записи: платеж, событие, сообщение, передача наличных;
 category	- категория платежа, более детально сообщает о внутреннем устройстве
		  текущей записи.
</pre>
<br>
Поле type может принимать строго такие значения:<br>
<br>
<pre>
10 - платеж клиента;
20 - временный платеж;
30 - сообщение/комментарий клиенту;
40 - передача наличных;
50 - событие.
</pre>
Типы 10 и 20 являются финансовыми платежами, т.е влияют на состояние счета клиента.
Сумма всех платежей с типами 10 и 20 строго соотвествует значению поля balance в таблице
users. При добавлении/удалении платежей с типом 10 и 20, система модифицирует поле
balance.<br>
<br>
Для записей с кодом 30 и 50, поле cash должно быть всегда равным 0.<br>
<br>
Тип 40 является внутренней проводкой, указывающей на перемещение наличности от одного
администратора к другому. В поле reason должен быть указан id администратора
передающего наличные, а в поле coment - принимающего наличные.<br>
<br>
Поле bonus, установленное в значение 'y' указывает на то, что платеж безналичный.
Для типа 20 всегда bonus='y'.<br>
<br>
Тип 30 указывает на то, что запись является либо сообщением либо комментарием. Чем именно
скажет поле category.<br>
<br>
Тип 50 наиболее обширный в описании. Как обычно, поле category регламентирует действие
записи с типом 50.<br>
<br>
В файле <em>paystype.pl</em> прописаны действия, которые необходимо применить для
расшифровки поля reason для определенных категорий событий.<br>
<br>
</div><br>
<br>
<br>



<br>
- <b>plans2</b> - таблица с тарифами.<br>
<br>

- <b>sat_log</b> - в эту таблицу агенты на сателлитах периодически записывают отчетную информацию, благодаря
чему появляется возможность их мониторить.<br>
<br>

- <b><a name="users">users</a></b> - таблица с данными клиентов:<br>
<br>
<div class="mess">
<pre>
 id		- id учетной записи клиента;
 ip		- ip в текстовом виде;
 name		- (теперь) логин;
 passwd		- закодированный пароль;
 grp		- группа (см. табл. user_grp);
 mid		- id основной записи;
 contract	- договор;
 contract_date	- timestamp заключения договора;
 state		- состояние доступа вкл/выкл;
 auth		- текущее состояние авторизации;
 balance	- баланс;
 money		- зарезервировано;
 limit_balance	- граница отключения;
 block_if_limit	- отключать ли запись при достижении границы отключения;
 sortip		- используеся при сортировки записей по ip;
 modify_time	- timestamp последней модификации записи;
 fio		- ФИО;
 srvs		- дополнительные услуги, каждый бит - услуга;
 paket		- номер пакета тарификации (см. табл. plans2);
 next_paket	- пакет на следующий месяц, 0 - не менять;
 hops		- (теперь) точка подключения;
 cstate		- техническое состояние (настроить/ремонт/вирусы...);
 cstate_time	- timestamp последнего изменения поля cstate;
 comment	- комментарий;
 lstate		- нужна авторизация/всегда онлайн;
 start_day	- &#171;день начала потребления услуг&#187;;
 detail_traf	- включить ли детализацию трафика.
</pre>

Исторически сложилось, что некоторые поля сменили свое назначение.<br>
<br>
У любого клиента всегда есть одна и только одна основная запись. Mid=0 указывает, что запись основная.
Все финансовые операции происходят только с этой записью. Дополнительные записи ссылаются на
основную через поле mid, которое указыват на ее id. В дополнительных записях поля balance, srvs и
start_day должны быть нулевыми. Значения полей grp и paket копируются из основной записи.
</div>
<br>
<br>

- <b>users_grp</b> - таблица описания групп клиентов. Кроме интуитивно понятных полей, включает
<em>grp_admins</em> и <em>grp_admins2</em>. В этих полях через запятую перечислены id администраторов, которые
имеют доступ к группе. Если администратор присутствует в обоих полях - ему дается полный доступ,
если в одном - ограниченный. Всегда в начале и конце списка стоит ноль. Администратора с id=0
нет в БД, эта внутренняя фича предназначена для упрощения поиска по регулярному выражению.<br>
<br>


- <b>traf_info</b> - содержит статистическую информацию о ходе снятия статистики: время, затраченное на выполнение
разных операций, количество обработанной информации и др. Позволяет вычислить слабые (наиболее нагруженные)
части системы.<br>
<br>
</pre><br>
<br>
<br>




<b><a name="cards">cards</a></b> - таблица карточек пополнения счета<br>
<br>
<div class="mess">
Структура:<br>
<br>
<pre>
cid		- серийный номер карты
cod		- код активации
money		- номинал
stime		- время генерации карты
etime		- время окончания действия
atime		- время активации
admin		- id админа, сгенерировавшего карту
alive		- состоянии карты
rand_id		- вспомогательное поле, используется системой при резервировании карточек
admin_sell	- id админа, который продал карточку
time_sell 	- время продажи карточки
id_sell		- id_sell указывает на id платежа в таблице pays
r		- id администратора, которому была передана карточка
</pre>
Время активации atime не равное нулю не гарантирует, что карта активирована!
Следует читать так: если карта активирована, то atime указывает на время ее активации.<br>
<br>
Состояние карты определяется полем alive, которое может принимать значения:<br>
<pre>
good	- карта не активирована и может быть активирована;
bad	- карта заблокирована;
move	- карта в состоянии перемещения, не может быть активирована пока не выйдет из этого состояния;
stock	- карта не активирована, не может быть активирована пока не выйдет из этого состояния;
число	- id клиента, которым активирована карта.
</pre>
<br>
Видно, что карту можно активировать только в единственном состоянии &#171;good&#187;. При генерации
картам устанавливается состояние &#171;stock&#187;, которое в админке именуется как &#171;можно активировать
после продажи&#187;. Из состояния &#171;stock&#187; в состояние &#171;good&#187; карта может перейти двумя способами:<br>
<br>
1) При продаже через админку NoDeny, когда администратор вручную вводит серийный номер карты. При этом
проводится платеж о продаже карточки.<br>
<br>
2) Администратор может самостоятельно перевести карточку из &#171;stock&#187; в &#171;good&#187; если ему даны
соответствующие права.<br>
<br>
Второй вариант предназначен строго для тех случаев, когда реализатор карточек не работает через админку NoDeny,
т.е. ведет учет карточек своими средствами. Поэтому продажа каждой карточки не регистрируется в биллинге.
Для того, чтобы клиенты имели возможность активировать такие карточки, последние необходимо вручную перевести
в состояние &#171;good&#187;.<br>
<br>
Первый вариант с реализацией карточек через админку более трудоемкий, но более надежный по безопасности т.к.
карточки могут быть активированы, только после того как была оформлена продажа каждой, т.е. при утере,
передачи карты клиенту без получения денег, такая карточка остается бесполезной для клиента.<br>
<br>
r>0 - указывает на id администратора, за которым числится эта карта.<br>
<br>
r=0 - устаревшая значение &#171;карточка на складе&#187;, сейчас r не может быть равным 0.<br>
<br>
admin_sell>0 - карточка продана админом с id = admin_sell, при этом устанавливается r=-2<br>
<br>
Важно: и r и admin_sell связывает карточку с администратором, однако есть
определенные тонкости: admin_sell не равный 0 указывает на то, что карточка была
продана через биллинг и что проведен соответствующий платеж. Т.е. деньги по
биллингу уже учтены. Естественно, карточки не обязательно продаются через биллинг,
например, передаются на реализацию. В этом случае речь не может идти о записи
в биллинг платежа о продаже карточки. Эти карточки учитываются через поле r.
Поэтому при подсчете &#171;наличности на руках&#187;, суммируются все номиналы карточек,
у которых поле r = id контрагента (администратора) и итоговая сумма числится за этим
администратором.<br>
<br>
При продаже карточки через биллинг поле r обязательно устанавливается в отрицательное значение для
того чтобы номинал этой карточки уже не числился за администратором, поскольку система
проводит дополнительный платеж о продаже данной конкретной карточки.<br>
<br>
Ситуация, когда r>0 и admin_sell>0 считается некорректной и не допускается.<br>
<br>
В биллинге также существует понятие ваучер. В отличие от карточек пополнения счета
(хотя ваучер и есть карточка пополнения со стороны клиента), ваучеры выдаются
биллингом в момент запроса, т.е. администратор указывает какой номинал ему необходим,
биллинг выбирает свободную карточку оплаты, устанавливает admin_sell,
проводит соответствующий платеж, после чего выводит данные карточки на экран.
Эти данные администратор может распечатать и передать клиенту.<br>
<br>
Обратите внимание, что в этом случае никакой передачи карточек не происходит, т.е.
не задействуется поле r. Однако предварительно все карточки, которые находятся
на складе и которые можно реализовать в виде ваучера должны быть помечены как r=-1.<br>
<br>
При передаче карточек от одного администратора к другому, из состояния &#171;good&#187; и &#171;stock&#187; они
переводятся в состояние &#171;move&#187;, а поле rand_id становится равным id администратора, на которого
оформляется передача. После подтверждения через админку принимающим администратором,
карточки переводятся в состояние &#171;stock&#187; (даже если до этого у них было состояние &#171;good&#187;).
Владелец (по полю r) карточек изменяется только после подтверждения передачи.
</pre>
</div>
<br><br>




<b><a name="files">files</a></b> - предназначена для хранения файлов. Необходимость в этом возникает,
когда система NoDeny распределена и требуется сателлитам передавать файлы со списком
сетей, по которым агент управления сформирует соответствующие правила. Например, точка обмена трафиком UA-IX,
в которую входит большое количесво сетей, постоянно изменяется. Если подгрузка списка сетей на сервер ядра
организована, то ядро NoDeny, при каждом обновлении списка сетей, будет обновлять соответствующие данные в
таблице files.<br>
<br>
<div class="mess">
Структура:<br>
<br>
<pre>
name		- имя файла
data		- содержимое файла
</pre>
</div>

Кроме того, таблица files выполняет вспомогательную роль контроля версий таблиц. Строка с зарезервированным
значением поля name, равным `tbl_version`, в поле data содержит номер версии таблиц NoDeny. Обратите внимание,
номер версий таблиц - это не версия NoDeny. Версия таблиц указывает в каком состоянии находятся структуры
всех таблиц NoDeny. Если разработчики производят изменения структуры какой-либо таблицы - это изменение
фиксируется под определенным номером в файле bill.sql. Таким образом, всегда есть возможность обновить
структуру таблиц до последней строго с той точки, которой они соответствуют. При инсталляции системы,
таблицы отсутствуют, принимается номер версии 0 и, следовательно, файл bill.sql обрабатывается полностью
по цепочке с самого первого sql-запроса, который, естественно, создает таблицу files, чтобы
иметь возможность фиксировать номера версий.<br>


<br>
<br>


<b><a name="arch">arch_users</a></b> - таблица с данными клиентов за прошлые месяцы<br>
<br>
<div class="mess">
Структура:<br>
<br>
<pre>
mon		- месяц
year		- год
uid		- id клиента
uip		- ip
grp		- группа
paket		- пакет
preset		- пресет
auth		- 1 - была хотя бы одна авторизация за месяц, 0 - не было
no_submoney	- причина по которой с клиента не снимались деньги при переходе на новый месяц:
	0 - деньги снимались (существует запись в таблице платежей)
	1 - группа клиента блокирует снятия, например группа &#171;разорвавшие договора&#187;
	2 - клиент еще не начал пользоваться услугами (день начала потребления услуг <0)
</pre>
Внимание. Если за определенный месяц и год для определенного клиента присутствует запись - это означает,
что при переходе на новый месяц (см. скрипт new_month.pl) клиент уже был обработан. Таким образом,
при повторном запуске скрипта не произойдет повторное снятие за услуги. Повторный запуск теоретически может
понадобиться в случае если во время перехода на новый месяц произошел сбой (например, проблемы соединения
с БД), т.е. когда переход мог произойти частично. В этом случае для оставшихся непереведенных клиентов
необходимо запустить new_month.pl повторно. 
</div>
<br>
<br>



<b><a name="login">login</a></b> - таблица авторизаций клиентов, хранит информацию о том, кто и когда
авторизовался для доступа в интернет.<br>
<br>
Агенты авторизации авторизуют клиентов и регистрируют это в таблице dblogin. Ядро периодически
с небольшим интервалом времени извлекает данные из этой таблицы, проводит проверки стоит ли отключить
по задолженности клиента, записывает более расширенную информацию в таблицу login. Обратите внимание,
данная таблица заполняется исключительно ядром.
<div class="mess">
Структура:<br>
<br>
<pre>
mid		- id клиента
act		- состояние авторизации
time		- время события в виде timestamp
</pre>
Состояние авторизации - число, которое состоит из двух частей: первая цифра - код, указывающий
каким методом авторизовался клиент, вторая - непосредственно режим авторизации.<br>
<br>
Метод авторизации:<br>
<br>
1 - с помощью программы-авторизатора;<br>
2 - PPPoE;<br>
3 - Web-авторизация;<br>
4 - на порту свича (802.1x).<br>
<br>
Режим авторизации:<br>
0 - <em>Перестал быть</em> авторизованным;<br>
1 - Авторизован. Доступ заблокирован: превышен лимит трафика;<br>
2 - Авторизован. Доступ заблокирован: превышен лимит денежной задолженности;<br>
4 - Авторизован. Доступ заблокирован: в данное время суток по условию пакета;<br>
5 - Авторизован. Доступ заблокирован;<br>
7 - Авторизован в режиме "полный доступ";<br>
8 - Авторизован в режиме "только сети направления 2";<br>
9 - Авторизован в режиме "выключен" (только локальная сеть).<br>
<br>
Например, act=19 указывает на то, что клиент авторизовался с помощью программы авторизатора в режиме &#171;выключен&#187;.
</div>

<br>
<br>
<b><a name="dopdata">dopfields / dopvalues / dop_oldvalues / dopdata</a></b> - таблицы, обеспечивающие механизм хранения
дополнительных полей данных.<br>
<br>

<ul>
<li>dopfields - характеристики полей данных</li>
<li>dopvalues - текущие данные клиентов/оборудования (далее объекты)</li>
<li>dop_oldvalues - неактуальные, попавшие в историю, данные объектов</li>
<li>dopdata - актуальные данные + характеристики этих данных (объединение таблиц dopfields и dopvalues)</li>
</ul>


<div class='code'><div class='mark'>структура dopfields</div>
<pre>
 id		- идентификатор поля
 template_num	- номер шаблона
 parent_type	- с каким объектом ассоциируется поле. 0 - с клиентом
 field_type	- тип поля: целое, строковое, да/нет, выпадающий список и т.д.
 field_name	- имя поля
 field_alias	- алиас имени
 field_flags	- строка флагов: убирать ли лидирующие/завершающие пробелы,
		  включить транслитерацию, привести к нижнему регистру и т.д.
 field_template	- регулярное выражение для проверки корректности заполнения поля
 comment	- комментарий
</pre>
</div>

<div class='code'><div class='mark'>структура dopfields</div>
<pre>
 parent_id	- хозяин данного параметра, id в таблице users
 dopfield_id	- ссылка на описание параметра в таблице dopfields (по полю id)
 field_value	- значение параметра
</pre>
</div>

<p>Таблица dopdata объединяет поля этих 2х таблиц.</p>


<p>Номер шаблона логически группирует поля. Например, в настройках NoDeny можно указать,
что в шаблоне `Адрес` хранятся данные адреса клиентов (улица, дом, квартира...),
а в шаблоне `Технические данные` хранятся параметры подключения.</p>

<p>Алиас поля предназначен для взаимодействия с внешними скриптами. Поле может
содержать короткое имя, кодирующее назначение поля. Например, `_adr_house` и `_adr_room`
позволяет модулям выуживать дома и квартиры клиентов.</p>

<p>Для того, чтобы перейти к описанию таблицы dop_oldvalues, рассмотрим механизм
создания/изменения данных определенного объекта.</p>


<p>Любые данные, которые назначаются объекту, сначала записываются в таблицу dop_oldvalues.
При этом в группе данных устанавливается уникальный номер ревизии, по которому в дальнейшем
можно произвести их выборку. Дело в том, что в отличие от dopvalues, где данные объекта
хранятся всегда в единственном экземпляре, dop_oldvalues хранит всю историю изменений,
т.е. одноименных параметров может быть несколько. Чем больше ревизия - тем более поздние
данные она описывает (поле время не может полностью логически заменить ревизию т.к.
в одну секунду возможно произвести несколько изменений одного объекта).</p>


<div class='code'><div class='mark'>структура dop_oldvalues</div>
<pre>
 parent_id	- хозяин данного параметра, id в таблице users
 dopfield_id	- ссылка на описание параметра в таблице dopfields (по полю id)
 field_value	- значение параметра
 admin_id	- id администратора, внесшего/изменившего данные
 time		- timestamp создания/изменения данных
 revision	- номер ревизии
</pre>
</div>

<p>После сохранения данных в dop_oldvalues, вызывается mysql-процедура set_dopvalues, которая
копирует эти данные в таблицу dopvalues поверх текущих (если они есть). Процедуре set_dopvalues
в качестве параметра передается номер ревизии. Перед копированием данных, процедура проверят
не конфликтуют ли они с данными другого объекта, помеченными как актуальными. Если обнаруживает
такую ситуацию, то копирование не происходит, а в качестве результата выполнения в вызываемый
скрипт (например dopdata.pl) возвращается код ошибки. Поскольку данные были промежуточно
сохранены в dop_oldvalues, у скрипта появляется возможность предложить оператору откорректировать
ошибочный параметр и сделать данные актуальными снова.</p>


<p>Кроме того, если при копировании в dopvalues из dop_oldvalues в последней отсутствуют
какие-либо поля, процедура set_dopvalues оставит их текущими. Это удобно в случае, когда в
админке идет сохранение данных, часть из которых ошибочна, например, одно из устанавливаемых полей
не соответствует шаблону, то это поле не сохраняется в dop_oldvalues. Таким образом в
dop_oldvalues попадают только корректные данные.</p>


</body>
</html>

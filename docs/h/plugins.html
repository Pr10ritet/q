<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Nodeny - Работа с биллингом</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<link rel='stylesheet' href='../i/nody.css' type='text/css'>
</head>
<body>
<div class='mainbody'>
<table border=0 width=90% class="coment"><tr>
<td><a href="../index.html"><img src="../i/logo.gif" border=0 valign=middle></a></td>
<td align=center><b>Биллинговая система NoDeny. Программирование плагинов клиентской статистики.</b></td>
</tr>
</table>

<div class='mainbody'>
<br>

NoDeny дает возможность самостоятельно нарастить функционал клиентской статистики
с помощью плагинов. Если вы уверенно программируете на perl, можете взяться за работу,
предварительно изучив следующее:<br>
<br>

Клиентская статистика предоставляется скриптом <b>stat.pl</b>, который загружает
необходимый плагин и выполняет его. Скрипт существует в двух абсолютно
одинаковых экземплярах: http://..../cgi-bin/stat.pl и http://..../cgi-bin/adm/stat.pl
- обусловлнено тем, что папка adm является административной и запаролена,
т.е клиенты не имеют к ней доступ, поэтому получают статистику через /cgi-bin/stat.pl.
С другой стороны, у администратора должна быть возможность посмотреть &#171;глазами клиента&#187;
на его статистику, что он и делает через /cgi-bin/adm/stat.pl.<br>
<br>


В задачи скрипта stat.pl входит: проверка авторизации, подготовка данных для плагинов,
запуск плагина.<br>
<br>


Плагины реализованы в виде файлов, имена которых начинаются с заглавной латинской буквы
<b>S</b>. Это условие не является обязательным, но рекомендуемым для соблюдения стиля.
Соблюдение стиля в разных аспектах NoDeny ведет к логичности в управлении и понимании.
Имя файла должно иметь расширение <b>pl</b>, это обязательное условие.<br>
<br>

Каждый плагин имеет свой уникальный номер, через который клиент его запускает.
Уникальность имени и номера плагина желательно согласовывать с автором для исключения
пересечения с плагинами других разработчиков.<br>
<br>

Данные о плагине содержатся в реестре плагинов - в файле <b>plugin_reestr.cfg</b>.
Каждая строчка файла описывает параметры плагина: имя файла, уникальный номер плагина,
название плагина, разрешить ли доступ к плагину только администратору и некоторые
другие данные, которые будут описаны ниже. В самом реестре даны комментарии по полям.<br>
<br>

Каким образом скрипту stat.pl сообщается какой плагин необходимо запустить?
Для этого в запросе, переданным через браузер, в переменной <b>a</b> указывается
уникальный код плагина, например:<br>

<div class="coment">http://.../stat.pl?a=102</div>
что указывает выполнить плагин с номером 102. Если переменная <b>a</b> не будет
определена, то будет запущен плагин с кодом 101 - отображена главная страница статистики.<br>
<br>

Перед тем как начать программировать плагины, изучите скрипт <b>calls.pl</b> - в нем
содержится много полезных подпрограмм.<br>
<br>

Что должно быть результатом выполнения плагина?<br>
<br>

Существует глобальная переменная <b>$OUT</b>, которая является фактически html-страницей,
которая будет возвращена клиенту. Код:<br>

<div class="code">$OUT.='Привет!'</div>
Добавит к формирующейся html-странице текст &#171;Привет!&#187;. После того, как плагин завершит свою
работу (выполнит return в скрипт stat.pl), stat.pl закончит формирование html-страницы -
закроет открытые теги, после чего пошлет страницу в бразуер клиенту.<br>
<br>

Последние действия в виде кода:
<div class="code">
   $OUT.=$EOUT;<br>
   &Exit;
</div>
Здесь $EOUT - переменная, содержащая список закрывающих тегов, а &Exit - подпрограмма из calls.pl,
которая &#171;приклеивает&#187; заголовок к $OUT, отсылает все клиенту в браузер и выполняет exit.<br>
<br>


Нормальное завершение плагина - это return в stat.pl, однако в случае, если плагин
фиксирует проблему или ошибочное действие, наилучшим вариантом будет запуск
подпрограммы Error, которая выведет сообщение об ошибке и сделает &Exit:<br>

<div class="code">&Error('Ошибка! Нет связи с ФБР!',$EOUT) unless &Connect_FBR;</div>
- обратите внимание на присутствие $EOUT вторым параметром в &Error. Если
заглянуть в calls.pl и изучить описание к &Error, то станет понятно, что
2й параметр добавляется к $OUT сразу после вывода ошибки.<br>
<br>

Изучите глобальные переменные, доступные внутри плагина:
<ul>
<li><a href="#Adm">%Adm</a></li>
<li><a href="#day_now">$day_now</a></li>
<li><a href="#Er_Mess_for_Client">$Er_Mess_for_Client</a></li>
<li><a href="#F">%F</a></li>
<li><a href="#id">$id</a></li>
<li><a href="#Mid">$Mid</a></li>
<li><a href="#nAlias">$nAlias</a></li>
<li><a href="#OUT">$OUTLEFT</a></li>
<li><a href="#p">$p</a></li>
<li><a href="#pm">$pm</a></li>
<li><a href="#RealIp">$RealIp</a></li>
<li><a href="#scrpt">$scrpt</a></li>
<li><a href="#start">$start</a></li>
<li><a href="#Sel_id">$Sel_id</a></li>
<li><a href="#t">$t</a></li>
<li><a href="#ut">$ut</a></li>
<li><a href="#U">%U</a></li>
<li><a href="#V">$V</a></li>
</ul>
<br>


Перечисленные переменные модифицировать не рекомендуется.
<br>
<br>




<div class="mess">
<b><a name="Adm">%Adm</a></b> - хеш данных администратора, просматривающего статистику.
Поскольку статистику обычно просматривает не администратор, а клиент, то в таком случае
хеш содержит всего одно значение: $Adm{id}=0. Создавая плагины вы всегда должны
помнить о том, что он может быть запущен как администратором так и клиентом, поэтому
хорошим стилем, а также условием безопасности, является пометка кем было
осуществлено действие клиентом или администратором.<br>
<br>
<b>$Adm{id}</b> - id администратора, либо 0, если статистику просматривает клиент.<br>
<br>
<b>$Adm{office}</b> - отдел администратора.<br>
<br>
<b>$Adm{login}</b> - логин администратора.<br>
</div>
<br>

<div class="mess">
<b><a name="F">%F</a></b> - хеш, содержащий данные, которые клиент послал через браузер.
Например, клиент послал запрос:<br>
<div class="coment">http://.../stat.pl?a=101&day=10</div>
Хеш %F будет заполнен такими значениями:<br>
<br>
$F{a}=101<br>
$F{day}=10<br>
<br>

Если в запросе одна и таже переменная встречается больше одного раза, то за основу берется
последнее значение, например:<br>
<div class="coment">http://.../stat.pl?a=101&amp;a=102</div>
<br>
Приведет к результату: $F{a}=102<br>
<br>
Эта особенность применяется, когда необходимо изменить уже существующий запрос. Например,
глобальная переменная <b>$scrpt</b> содержит url текущей страницы вместе с переданными данными,
скажем:
<div class="coment">$scrpt = 'stat.pl?pp=...&amp;a=101&amp;day=10&amp;mon=2&amp;year=2008'</div>
<br>
мы хотим сформировать ссылку на страницу для отображения статистики не на 10 февраля, а на
11 марта:
<div class="code">&ahref("$scrpt&amp;day=11&amp;mon=3",'показать статистику');</div>
</div>

<div class="mess">
<b><a name="RealIp">$RealIp</a></b> - ip с которого в данный момент просматривается статистика.
Обратите внимание, что это не ip клиентской записи, это ip с которого произведен "заход"
в клиентскую статистику.
</div>

<div class="mess">
<b><a name="start">$start</a></b> - номер отображаемой страницы, когда система выводит фрагмент таблицы
(определенную страницу). Найдите подпрограмму &Show_navigate_list в каком-нибудь плагине,
чтобы понять где и как используется $start.
</div>


<div class="mess">
<b><a name="Sel_id">$Sel_id</a></b> используется тогда, когда у клиента несколько учетных записей и
статистика может выводиться отдельно для каждой учетной записи либо же суммарная для всех. 
Например, статистику трафика можно показать для основной записи либо же для алиасной, либо же
суммарную. В переменной $Sel_id содержится список id, разделенных запятыми, для которых клиент запросил
статистику. 
<div class="code">
$OUT.=$For_U? "Запрошен вывод телефона для $For_U" : 'Запрошен вывод телефонов всех записей клиента';<br>
$sth=&sql("SELECT telefon FROM users WHERE id IN ($Sel_id)");
</div>

</div>



<div class="mess">
<b><a name="Er_Mess_for_Client">$Er_Mess_for_Client</a></b> - сообщение &#171;Данные недоступны -
ведутся технические работы на сервере.&#187;. Это &#171;отмазка&#187; для клиентов, когда произошла
критическая ошибка, которую нельзя сообщать клиенту, администратору же ошибка выводится - смотри описание
к переменной <a href="#V">$V</a>.
</div>


<div class="mess">
<b><a name="day_now">$day_now</a></b>
<pre>
$day_now	- текущий день
$mon_now	- текущий месяц (1..12)
$year_now	- текущий год (от 1970!)
</pre>
</div>

<div class="mess">
<b><a name="p">$p</a></b> - ссылка на выборку из таблицы БД для текущей клиентской записи
<div class="code">$OUT.='Квартира клиента: '.$p->{room};</div>
</div>

<div class="mess">
<b><a name="pm">$pm</a></b> - ссылка на выборку для основной записи клиента. Если просматривается
основная запись, то $p и $pm указывают на одну и туже структуру данных.
</div>

<div class="mess">
<b><a name="Mid">$Mid</a></b> - id основной записи клиента. Пример:
<div class="code">
 $h=&sql_select_line($dbh,"SELECT COUNT(mid) FROM pays WHERE mid=$Mid AND type=30');<br>
 $OUT.='Клиент отправил/получил '.$h->{'COUNT(mid)'}.' сообщений за все время сущестрования его учетной записи';
</div>
Обратите внимание - у клиента может быть несколько учетных записей (алиасов). Клиентстая статистика
может просматриваться от имени алиаса. Поэтому чтобы отобразить некоторые данные, которые существуют только
для основной записи (к примеру платежи), необходимо использовать $Mid.
</div>


<div class="mess">
<b><a name="id">$id</a></b> - id текущей записи. Если просматривается основная запись, то $Mid=$id
</div>

<div class="mess">
<b><a name="U">%U</a></b> - данные всех учетных записей клиента.<br>
<pre>
$U{$id}{name}	- логин
$U{$id}{ip}	- ip
$U{$id}{fio}	- фио
$U{$id}{state}	- состояние записи заблокирована/не заблокирована
$U{$id}{o_name}	- логин с отфильтрованными спецсимволами html
$U{$id}{m_name}	- логин с отфильтрованными спецсимволами mysql
$U{$id}{o_fio}	- фио с отфильтрованными спецсимволами html
$U{$id}{m_fio}	- фио с отфильтрованными спецсимволами mysql
</pre>
Пример:<br>
<br>
<div class="code">$OUT.='Логин основной записи: '.$U{$Mid}{o_name};</div>
<br>

Важно.<br>
<br>

Не забывайте о безопасности, а именно о фильтрации спецсимволов в непроверенных данных,
в противном случае злоумышленник сможет повредить/получить данные из БД путем посылки
некорректных данных. Не исключайте, что злоумышленником может быть и ненадежный работник.
Учтите, в данных таблиц базы данных содержатся нефильтрованные значения. Например,
допускается фамилия <b>&lt;b&gt;Иванов&lt;/b&gt;</b>. Поэтому при выводе данные в виде html
всегда применяйте фильтр &Filtr_out, а при выполнении sql-запроса &Filtr_mysql.
Это разные фильтры!<br>
<br>
<div class="code">$OUT.='В переменной privet вы прислали: '.&Filtr_out($F{privet});</div>
</div>




<div class="mess">
<b><a name="nAlias">$nAlias</a></b> - количество учетных записей клиента. Если нет
алиасов, то = 1.
</div>


<div class="mess">
<b><a name="OUTLEFT">$OUTLEFT</a></b> - всеб что будет добавлено к этой переменной,
будет выведено в левую колонку клиентской статистики. Аналогично как все, что добавляется
в $OUT - выводится в правую колонку. Однако, есть нюанс. В левую колонку можно
добавлять данные строго до выполнения основного кода плагина, имеется ввиду
подпрограмма, которая описывается в реестре.<br>
<br>
Чтобы было понятней, необходимо описать детальнее процесс запуска плагина:<br>
1) stat.pl производит авторизацию.<br>
2) stat.pl получает данные клиента.<br>
3) stat.pl формирует меню плагинов (левую колонку статистики). В этот момент
происходит импортирование плагина. Т.е плагин загружается, но подпрограмма,
указанная в реестре, не выполняется. Выполняется лишь код, оформленный вне
подпрограмм плагина. В этом коде и предусматривается обновление $OUTLEFT.
Смотрите <b>Sdemo.pl</b> для примера.<br>
4) stat.pl завершает формирование левой колонки, начинает формирование правой.<br>
5) выполняется заданная подпрограмма плагина.
<br>
</div>




<div class="mess">
<b><a name="scrpt">$scrpt</a></b> - url текущей страницы со ссылкой на текущий плагин
(с установленным уникальным номером плагина <b>a</b>).
<br>
<div class="code">&ahref($scrpt,'Запустить текущий плагин без параметров');<br></div>
<div class="code">&ahref("$scrpt&amp;a=101",'Титульная страница статистики');<br></div>
</div>



<div class="mess">
<b><a name="t">$t</a></b> - время на сервере основной БД. Это время принято за основу,
поскольку в системе с большим количеством серверов могут быть значительные расхождения
во времени. Во всех расчетах применяйте переменную $t. Для записи в БД используйте значение
unix_timestamp()
<br>
<div class="code">&sql_do($dbh,"INSERT INTO pays SET mid=$Mid,type=30,coment='Привет!',time=unix_timestamp()");</div>
</div>



<div class="mess">
<b><a name="ut">$ut</a></b> - строка 'unix_timestamp()'
</div>



<div class="mess">
<b><a name="V">$V</a></b> - если установлена, то означает, что статистику просматривает
не клиент, а администратор. Предназначено для того, чтобы администратору сообщать более
детальные сообщения об ошибках.<br>
<br>
Когда переменная $V установлена, то содержит такое сообщение:<br>
<br>
<em>&#171;Вы в режиме администрирования, поэтому вам видны более детальные описания ошибок:&#187;</em><br>
<br>
Таким образом, если в плагине ввести следующую строку:
<div class="code">
&Error($V? "$V повреждение данных!" : 'Временная ошибка. Повторите запрос позже');
</div>
То при запуске плагина клиентом, ему будет показано сообщение:<br>
<br>
<div class="coment">Временная ошибка. Повторите запрос позже</div>
<br>
Администратору же:<br>
<br>
<div class="coment">
Вы в режиме администрирования, поэтому вам видны более детальные описания ошибок:<br>
<br>
повреждение данных!
</div>
</div>


<br>
</div>
<br><br><br><br>
<br><br><br><br>
<br><br><br><br>
<br><br><br><br>
<br>
<br>
<br>
<br></body>
</html>

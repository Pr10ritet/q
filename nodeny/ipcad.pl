#!/usr/bin/perl
# ¬ход:
# 0 - сервер
# 1 - название файла
#
# —крипт должен уложитс€ в 60 секунд, если не уложитс€, то данные будут проигнорированы
#
# ¬нимание разработчику.
# 1) — новыми верси€ системы не забывай провер€ть поведение команды rsh
#   — консоли запускай такую проверку:
#    rsh -t 2 0.0.0.0 show version >/dev/null
#   - результатом должен быть вывод на консоль ошибки невозможности соединени€ 
#    (важен сам факт вывода текста в поток ошибок)
#    rsh -t 2 0.0.0.0 show version 2>/dev/null
#   - результатом должен быть полностью пустой вывод! (ошибка должна уйти в null)
#  ¬ажно такое поведение rsh т.к при сн€тии статистики сначала запускаетс€ 2й вариант
#  и если вывод отсутствует, что считаетс€, что соединение не осуществлено, после чего
#  запускаетс€ первый вариант дл€ того чтобы получить причину ошибки
#

$rsh=`which rsh` || '/usr/bin/rsh';

chomp($rsh);

($dserver,$file_name)=@ARGV;

$rsh.=" -l $1" if $dserver=~s/:(.+)$//;
$rsh.=" -t";

# перемещение текущих данных в checkpoint
$com1=qq{$rsh 5 -n $dserver "cle ip acco" 2>/dev/null};
# получение данных их чекпоинта
$com2=qq{$rsh 20 -n $dserver "sh ip acco che" 2>/dev/null};

$rez=`$com1`;
$rez=`$com1` unless $rez; # бывали случаи, что из-за глюка с первого раза не устанавливаетс€ соединение
exit unless $rez;
$rez=`$com2`;
$rez=`$com2` unless $rez;
$temp_name=$file_name.'_temp';
if( open F,">$temp_name" )
{
   print F $rez;
   close(F);
}
rename $temp_name,$file_name;
exit;

